코틀린 람다를 자바 API에 사용해도 아무 문제가 없다는 사실을 다행으로 여겨야한다.

그러면 어떻게 코틀린 람다를 자바 API에 활용할 수 있는지 알아보자.

일반적으로 자바에서는 인터페이스를 인자로 받는 경우 무명 클래스 인스턴스를 만들어서 사용했다.

하지만, 자바에서는 이 무명 클래스 인스턴스 대신 람다를 넘겨 사용할 수 있다.

다시 한번 의문점을 가져보자. `어떻게? 가능할까?`

가능한 이유는 예를 들어 ClickListener같은 경우에 onClickListener가 추상메소드를 단 하나 가지기 때문이다.

추상메소드를 단 하나 가지는 인터페이스를 **함수형 인터페이스 (functional interface)** 혹은 **SAM 인터페이스 (SAM = Single Abstract Method)** 라고 한다.

따라서, 자바에서 함수형 인터페이스를 인자로 취하는 자바 메소드를 코틀린에서는 람다로 사용할 수 있게 해준다.

정리하면, 함수형 인터페이스를 인자로 취하면 코틀린에서는 람다를 사용하여 자바 메소드를 사용한다. 그렇기 때문에 무명 클래스 인스턴스 대신에 람다를 사용한다. 라고 말을 할 수 있다.

이 말의 의미가 무명 클래스 인스턴스가 내부적으로 대체되었다는 뜻일까?

## 5.4.1 자바 메소드에 람다를 인자로 전달

코틀린에서 함수형 인터페이스를 인자로 취하는 자바 메소드에 람다를 사용한다면, 코틀린 컴파일러는 `자동으로 람다를 함수형 인터페이스 인스턴스로 변환`한다.

`함수형 인터페이스 인스턴스란?` 무슨 의미일까?
> 함수형 인터페이스를 구현한 무명 클래스의 인스턴스 라는 의미
> 컴파일러는 자동으로 그런 무명 클래스와 인스턴스를 만든다

즉 다시 말해서, 위의 질문인 '무명 클래스 인스턴스가 내부적으로 대체되었는가?'에 대한 대답은 `No`이다.

#### 람다와 무명 객체 사이에는 차이점이 없을까?
객체를 명시적으로 선언하는 경우 메소드를 실행할 때마다 새로운 객체가 생성된다. 하지만 람다는 다르다. 

포획 변수를 사용하지 않는 람다를 사용하고 있다면, 람다에 대응하는 무명 객체를 메소드 호출때마다 반복 사용한다.

그러면 포획 변수를 사용하면 어떻게 될까?

매 호출마다 포획 변수의 값을 확인하기 위해 새로운 인스턴스를 생성한다.

```kotlin
fun hnadleComputation(id: String) {
  postponeComputation(1000) { printnln(id) }
}
를 decompile 하면,

class HandleComputation$1 (val id: String) : Runnuable {
  override fun run() {
    println(id)
  }
}

fun handleComputation(id: String) {
  postponeComputation(1000, HandleComptuation$1(id))
}
```
위와 같은 구조를 갖게 된다.

따라서, 포획 변수가 있다면 무명 객체와 람다 사이에는 차이가 없다.
하지만, 포획 변수가 없다면 무명 객체와 람다 사이에는 새로운 객체를 생성하냐 생성된 객체를 반복 사용하느냐의 차이가 존재한다.

#### inline은 좀 다른가?
inline으로 표시된 코틀린 함수에게 람다를 넘기면 아무런 무명클래스도 만들어지지 않는다.

코드 블록을 복사해서 사용하기 때문이다.

8장에서 inline을 다루므로 8장에 갈 때까지 궁금증을 참아야 한다.

## 5.4.2 SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경

**SAM 생성자**: 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수

SAM 생성자의 이름은 함수형 인터페이스의 이름과 같다.

아래 코드는 SAM 생성자를 사용해 값을 반환한 경우다. (함수형 인터페이스의 인스턴스르 반환하는 메소드가 있다면 람다를 직접 반환할 수 없다)
```kotlin
fun createAllDoneRunnable(): Runnuable {
  return Runnable { println("All done!") }
}
```

SAM 생성자를 통해 만들어진 인스턴스를 변수로 저장하여 여러 곳에서 사용할 수도 있다.

ex) clickListener에 등록

> 람다는 코드 블록이기 때문에 객체가 아니다. 따라서 람다 블록 내부에서 호출하는 this는 람다를 둘러싼 클래스의 인스턴스를 가리킨다.
> 따라서, 리스너 등록후 해제해야 한다면 무명 객체를 사용해 리스너를 구현해야한다. 무명 객체는 객체이기 때문에 내부의 this는 무명객체 인스턴스를 가리킨다.
