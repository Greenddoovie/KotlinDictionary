## 6.3.1 널 가능성과 컬렉션

1. 컬렉션의 원소가 널이 되는 경우
2. 컬렉션이 널이 되는 경우

존재한다

## 6.3.2 읽기 전용과 변경 가능한 컬렉션

코틀린 컬렉션과 자바 컬렉션의 큰 차이는 코틀린은 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다.

따라서 코틀린은 `Collection`과 `MutableCollection`이 존재하고 컬렉션의 데이터를 변경하는 컬렉션의 경우 Super Class를 쫓아가다보면 `MutableCollection`이 존재한다.

또한 메모리 상에 위치한 컬렉션이 어떤 변수는 읽기 전용으로 타입 캐스팅을 해서 사용한다 하더라도, 다른 변수에서 데이터가 변경 가능한 타입으로 캐스팅해서 사용할 수 있다.

따라서 이런 경우, 해당 변수를 병렬 실행한다면 컬렉션 사용 도중에 내용이 변경되는 상황이 발생한다.

즉, 읽기 전용 컬렉션이 항상 **Thread Safe** 하다는 의미가 아니다.

## 6.3.3 코틀린 컬렉션과 자바

코틀린 컬렉션은 자바의 컬렉션의 인터페이스의 인스턴스이기 때문에 코틀린과 자바 사이를 오갈 때 어떠한 변환도 필요 없다.

즉, 코틀린은 자바 컬렉션의 인터페이스를 두 가지 형태 [읽기 전용, 데이터 변경]으로 나누어 사용할 뿐이다.

이러한 성질로 인해서 코틀린의 읽기 전용 컬렉션이 자바에서 사용된다면 자바 코드에서는 이 컬렉션 객체의 내용을 변경할 수 있다.

따라서, 컬렉션을 자바로 넘기는 코틀린 프로그램을 만들고 있다면 자바 코드에서 컬렉션을 변경하는지 안하는지 문맥을 분석하여 코틀린 프로그램을 짤 때 올바른 타입을 사용하는 수 밖에 없다.

데이터 변경 뿐 만 아니라 `Null`에 대해서도 이런 함정이 존재한다.

자바로 넘어온 컬렉션은 Null 값을 원소로 넣을 수 있으므로 의도치 않게 사용될 수 있다.

## 6.3.4 컬렉션을 플랫폼 타입으로 다루기

자바 코드에 선언된 컬렉션을 코틀린에서 어떻게 다루는지 살펴보자

코틀린은 자바 코드에서 정의한 타입을 플랫폼 타입으로 본다.

플랫폼 타입으로 보기 때문에 Nullable에 대한 정보가 없어 코틀린은 어느 타입으로든 사용할 수 있게 허용한다.

자바에서 넘어온 컬렉션의 경우 변경 가능성에 대해서 코틀린은 어떤 타입 [읽기 전용, 데이터 변경]으로 선택할 수 있게 허용한다.

코틀린 코드는 컬렉션 타입을 읽기 전용 컬렉션이나 변경 가능한 컬렉션 어느 쪽으로든 다룰 수 있다.

대부분의 경우 수행이 잘 되겠지만, 자바 인터페이스를 코틀린 코드로 구현해야 하는 경우에 잘 고려해서 메소드를 오버라이드 해야한다

- 컬렉션이 널이 될 수 있는지?
- 컬렉션의 원소가 널이 될 수 있는지?
- 오버라이드 메소드가 컬렉션을 변경하는지?

```kotlin
// Java
interface FileContentProcessor {
  void processContnets(
    File path,
    byte[] binaryContents
    List<String> textContents
  );
}
// Kotlin
class FileIndexer: FileContentProcessor {
  override fun processContents(
    path: File,
    binaryContents: ByteArray?,
    textContents: List<String>?
  )
}
```

자바 인터페이스 혹은 클래스를 코틀린에서 상속하여 메소드를 오버라이딩할 때 어떤 맥락에서 사용되는지 정확히 알아야 한다. 

그래야 위의 고려사항에 대한 답을 내리고 적절한 타입을 사용할 수 있다.

## 6.3.5 객체의 배열과 원시 타입의 배열

코틀린에서 배열을 만드는 방법
1. arrayOf 함수에 원소를 넘긴다
2. arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 Null 이고 인자로 넘긴 값과 크기가 같은 배열을 만든다. 원소타입이 null 이 가능한 경우에 사용한다
3. Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해 배열 원소를 초기화한다

코틀린의 원시 타입 배열을 위한 클래스를 하나씩 제공한다.

예를 들어, IntArray, ByteArray, CharArray, BooleanArray 등이 있다.

원시 타입 배열 만드는 방법
1. 생성자로 size 인자로 받고 해당 원시 타입의 디폴트로 초기화된 배여려 생성한다
2. 가변 인자를 받아 생성한다
3. 크기와 람다를 받아서 람다를 호출해 배열 원소를 초기화한다

이 밖에 박싱된 컬렉션 혹은 배열을 toIntArray 등의 변환 함수를 사용해 래퍼 타입이 아닌 배열로 변환할 수 있다.
