코틀린은 원시 타입과 래퍼 타입을 구분하지 않고 사용한다.

### 6.2.1 원시 타입: Int, Boolean 등
자바의 경우 원시 타입과 래퍼 타입을 구분하여 사용한다.

원시 타입의 변수에는 값이 직접 들어가지만, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.

코틀린은 위에서 원시 타입과 래퍼 타입을 구분하지 않고 사용한다고 말했다. 

그러면 컴파일 타임에 어떤 타입으로 들어가게 될까?

코틀린은 가능한 한 가장 효율적인 방식으로 표현된다. 따라서 대부분의 경우 코틀린의 Int 타입은 자바의 int 타입으로 컴파일된다.

하지만 컬렉션과 같은 제네릭 클래스를 사용하는 경우에 Integer 타입으로 컴파일된다.

### 6.2.2 널이 될 수 있는 원시 타입: Int?, Boolean? 등

코틀린에서 Null이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다.

### 6.2.3 숫자 변환

코틀린 컴파일러는 숫자의 타입을 다른 타입의 숫자로 `자동` 변환하지 않는다.

코틀린에서는 `명시적`으로 타입을 변환해야합니다.

예를 들어서
```kotlin

// Error
val i = 1
val l: Long = i

// OK
val i = 1
val l: Long - i.toLong()
```

### 6.2.4 Any, Any?: 최상위 타

코틀린에서 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이고, Any? 타입이 모든 널이 될 수 있는 타입의 조상타입이다.

Any가 모든 타입의 조상이라는 의미는, 코틀린 클래스의 toString(), equals(), hashCode() 메소드가 Any에 정의되어 있고 상속했음을 의미한다.

하지만 Java의 Object와 대응이 되지 않기 때문에 Object의 메소드를 사용해야 한다면 타입 캐스팅을 해야한다.

### 6.2.5 Unit 타입: 코틀린의 void

코틀린의 Unit 타입은 자바 void와 같은 기능을 한다.

#### void와 Unit의 차이점

Unit은 모든 기능을 갖는 일반적인 타입으로 void와 달리 Unit을 타입 인자로 사용할 수 있다.

Unit 타입에 속한 값은 단 하나로, 그 이름도 Unit이다. 

Unit 타입 함수는 묵시적으로 Unit을 반환한다.

### 6.2.6 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.

Nothing 타입은 아무 값도 포함하지 않는다.

따라서, Nothing 타입은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

다른 용도에 쓰일 경우, 값을 포함하지 않기 때문에 변수에 의미가 없다.
