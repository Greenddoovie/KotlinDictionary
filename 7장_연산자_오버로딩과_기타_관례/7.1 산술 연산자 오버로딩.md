## 7.1.1 이항 산술 연산 오버로딩

연산자를 오버로딩 하는 경우, 반드시 `operator` 키워드를 붙혀야한다.
> operator 키워드는 어떤 함수가 관례를 따르는 함수임을 명확히 한다


> 만약, operator 키워드를 안붙히고 오버라이딩을 한다면 어떻게 될까?
> "operator modifier is reuqired ..." 라는 오류가 발생한다

코틀린은 연산자를 정의하여 사용할 수는 없고 언어에서 미리 정해준 연산자만 오버로딩할 수 있다.

관례를 따르는 연산자는 이미 정해져 있다.

|식 | 함수 이름|
| --- | --- |
| a * b | times |
| a / b | div |
| a % b | mod(1.1부터 rem)|
|a + b | plus |
| a - b | minus |

ex)
```kotlin
data class Point(val x: Int, val y: Int) {
  operator fun plus(other: Point): Point {
    return Point(x + others.x, y + others.y)
  }
}

operator fun Point.plus(other: Point): Point = Point(x + other.x, y + other.y)
```

연산자 우선순위는 숫자 타입에 대한 연산자 우선 순위와 같다

**주의사항**

1. 피연산자 (위의 a,b)가 같은 타입일 필요는 없다
2. 피연산자 타입과 결과 타입이 같을 필요는 없다
3. 연산자 오버로딩이 가능하다

## 7.1.2 복합 대입 연산자 오버로딩

복합 대입 연산자 오버로딩: `+=, -=, *=, /=` 를 의미

해당 연산자는 변경 가능한 변수에만 사용할 수 있다.
> a = a + b 이기 때문에, 재할당을 진행한다.

경우에 따라서, 내부 객체의 상태를 변경시키는 용도로도 사용할 수 있다.
> list += 42 
> 의미: list.add(42)

**주의사항**

코드적으로 `+=`는 plus와 plusAssing 으로 컴파일 할 수 있다.

따라서, 두 함수를 모두 정의하고 둘 다 `+=`에 사용 가능한 경우, 컴파일러는 오류를 보고한다

그러므로, 둘 중에 하나만 정의해서 사용해야 한다.

### Collection
#### +, - 의 경우
항상 새로운 컬렉션 반환

#### +=, -= 의 경우
변경 가능한 컬렉션에 작용해서 메모리에 있는 객체 상태를 변화

읽기 전용 컬렉션에 작용해서 적용한 복사본을 반환(var로 선언한 읽기 전용 컬렉션에만 적용 가능)

## 7.1.3 단항 연산자 오버로딩

단항 연산자도 이항 연산자 오버로딩과 마찬가지로 `operator`키워드르 사용하면 된다.
> 참고로 단항은 `unary` 라고 한다.

|식 | 함수 이름|
| --- | --- |
| +a  | unaryPlus |
| -a | unaryMinus |
| !a | not |
| ++a, a++ | inc |
| --a, a-- | dec |
